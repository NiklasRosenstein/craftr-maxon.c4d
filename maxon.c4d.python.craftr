# -*- mode: python -*-
# craftr_module(maxon.c4d.python)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
'''# Cinema 4D Python Utilities

This Craftr modules contains useful functions to help developing
Cinema 4D Python plugins. It allows you to easily create Python eggs
of external modules that you are using in a Plugin, extract Cinema 4D
dialog and description resource symbols and automatically protect
your Python plugin files (requires the [apex][] plugin to be installed).

> Note: This file is a Craftr module but must be compatible with most
> Python versions as some of its functions run this file as a script
> in a sub-process.

## Resource symbols

The Python API does not come with a built-in functionality to access
the dialog and description resource symbols of a Cinema 4D plugin. Manually
hardcoding the symbols into a Python plugin's source is not an option for
larger plugins. This module allows you to extract the resource symbols and
format them as a Python file, a class or in JSON format.

```python
# craftr_module(my_plugin)
from craftr.utils.path import *

session.path.append(join(project_dir, '..'))
python = load_module('maxon.c4d.python')

def symbols():
  python.symbols_format(project_dir, None, format='class')
  # or
  symbols_file = join(project_dir', 'devel', 'res.py')
  python.symbols_format(project_dir, symbols_file, format='file')
```

This will format the symbols as a Python class and output it to stdout
or write the symbols formatted as a Python file to the `devel/res.py`
file.

## External modules

First, you *must* use `_localimport` to import libraries that are
distributed with your plugin. You can find a version that you can
copy & paste into your plugins source file [here][_localimport].

If you want to use, and therefore also distribute, external Python modules
with your plugin that you don't want to distribute in source (make sure that
is allowed by the modules license), you can generate binary Python eggs
using the functionality in this module.

The following examples assume that you have external Python modules
in a `devel` directory. For distribution, they shall be compiled and
archived to the `res/modules2.6` and `res/modules2.7` directories.

    my_plugin\
      devel\
        res.py
        my_plugin_tools\
          __init__.py
          some_tools.py
        some_package\
          setup.py
          src\
            some_package\
              __init__.py
          etc...

This script does exactly that.

```python
from craftr.utils.path import *
session.path.append(join(project_dir, '..'))
python = load_module('maxon.c4d.python')


class PythonDistro(python.C4DDistro):
  # The base directory that contains the sources.
  source_dir = join(project_dir, 'devel')

  # The directory in which the compiled modules should be saved to.
  res_dir = join(project_dir, 'res')

  # The versions to compile for. Defaults to exactly this value.
  versions = ['2.6', '2.7']

  # A list of directory names that are to be compiled using setuptools.
  setuptools_packages = ['some_package']

  # A list of packages that should be compiled and archived manually
  # without a setup.py script. The first item in the sub-list is the
  # output filename of the egg.
  manual_packages = [
    ['my_tools-{py}.egg', 'res.py', 'my_plugin_tools'],
  ]
```

This can now be invoked using `craftr -fPythonDistr`. It requires that
the programs `python2.6` and `python2.7` are present in your `PATH`!

## Protecting your Python plugin from the command-line

__Important__: This requires the [apex][] plugin to be installed to
the Cinema 4D version you are developing the plugin in.

```python
def protect():
  pyp_file = join(project_dir, 'my_plugin.pyp')
  maxon.c4d.python.protect_pyp(pyp_file)
```

[apex]: https://github.com/nr-plugins/apex
[_localimport]: https://gist.github.com/NiklasRosenstein/f5690d8f36bbdc8e5556
'''

from __future__ import print_function

import glob
import json
import os
import pipes
import py_compile
import re
import subprocess
import sys
import zipfile

# =====================================================================
#  Resource symbol stuff
# =====================================================================

def parse_symbols(filename_or_fp):
  if isinstance(filename_or_fp, str):
    with open(filename_or_fp) as fp:
      return parse_symbols_string(fp.read())
  else:
    return parse_symbols_string(filename_or_fp.read())


def parse_symbols_string(string):
  ''' Parses a Cinema 4D resource symbol header and returns a
  dictionary that maps the symbol names with their ID and a list that
  contains all symbols that are masked by other fields declared later.

  Returns:
    tuple: `(dict, list)` '''

  # Remove all comments from the source.
  string = ' '.join(line.split('//')[0] for line in string.splitlines())
  string = ' '.join(re.split(r'\/\*.*\*\/', string))

  # Extract all enumeration declarations from the source.
  enumerations = [
    text.split('{')[1].split('}')[0]
    for text in re.split(r'\benum\b', string)[1:]
  ]

  # Load the symbols.
  symbols = {}
  masked_symbols = []
  for enum in enumerations:
    last_value = -1
    for name in enum.split(','):
      if '=' in name:
        name, value = name.split('=')
        value = int(value)
      else:
        value = last_value + 1

      name = name.strip()
      if name:
        if name in symbols and symbols[name] != value:
          masked_symbols.append((name, symbols[name]))
        last_value = value
        if not name.startswith('_'):
          symbols[name] = value

  return (symbols, masked_symbols)


def get_resource_files(plugin_dir):
  ''' Returns a dictionary with various contents about a plugin's
  resource folder. Returns None if there is not resource folder. '''

  resfolder = os.path.join(plugin_dir, 'res')
  c4d_symbols = os.path.join(resfolder, 'c4d_symbols.h')
  if not os.path.isdir(resfolder) or not os.path.isfile(c4d_symbols):
    return None

  results = {
    'res': resfolder,
    'c4d_symbols': c4d_symbols,
    'description': [],
    }

  for desc in glob.iglob(os.path.join(resfolder, 'description', '*.h')):
    results['description'].append(desc)

  return results


def symbols_format(plugin_dir, outfile, fmt):
  ''' Parses the symbols of the specified *plugin_dir* and formats
  it based on the specified *format*. If *outfile* is specified, it
  will be written into that file, otherwise it will be output to
  stdout.

  *format* by be one of `'json'`, `'file'` or `'class'`. *plugin_dir*
  may be a list of directories as well in case multiple plugin resource
  should be parsed together. '''

  if fmt not in ('json', 'file', 'class'):
    raise ValueError('invalid fmt value', fmt)

  if isinstance(plugin_dir, str):
    dirlist = [plugin_dir]
  else:
    dirlist = plugin_dir

  # Symbol name -> tuple of (value, filename).
  symbols = {}
  desc_symbols = {}

  def merge_symbols(filename, dest):
    symbols, masked = parse_symbols(filename)
    for symbol, value in masked:
      print("Warning ({}): {} ({}) masked".format(
        os.path.relpath(filename), symbol, value), file=sys.stderr)
    for symbol, value in symbols.items():
      has_value, source = dest.get(symbol, (None, None))
      if source is not None and has_value != value:
        print("Warning ({}): {} ({}) masking same symbol from {} ({})".format(
          os.path.relpath(filename), symbol, value, os.path.relpath(source),
          has_value), file=sys.stderr)
      dest[symbol] = (value, filename)

  for plugin_dir in dirlist:
    files = get_resource_files(plugin_dir)
    if files is None:
      raise ValueError('no resource directory in {!r}'.format(plugin_dir))

    merge_symbols(files['c4d_symbols'], symbols)
    for filename in files['description']:
      merge_symbols(filename, desc_symbols)

  # Unpack the values from the (value, filename) tuples.
  unpack = lambda x: dict((k, v) for k, (v, __) in x.items())
  symbols = unpack(symbols)
  desc_symbols = unpack(desc_symbols)

  fn = globals()['symbols_format_' + fmt]
  if outfile:
    with open(outfile, 'w') as fp:
      fn(symbols, desc_symbols, fp)
  else:
    fn(symbols, desc_symbols, sys.stdout)
    print()


def symbols_format_json(symbols, desc_symbols, fp):
  all_syms = symbols.copy()
  all_syms.update(desc_symbols)
  json.dump(all_syms, fp)


def symbols_format_file(symbols, desc_symbols, fp):
  template = load_template('symbols_file')
  formatted = symbols_preformat(symbols, desc_symbols)
  print(render_template(template, symbols=formatted), file=fp)


def symbols_format_class(symbols, desc_symbols, fp):
  template = load_template('symbols_class')
  formatted = symbols_preformat(symbols, desc_symbols)
  print(render_template(template, symbols=formatted), file=fp)


def symbols_preformat(symbols, desc_symbols):
  def preprocess(symbols):
    if not symbols: return
    maxlen = max(len(sym) for sym in symbols)
    for name, value in sorted(symbols.items(), key=lambda x: (x[1], x[0])):
      if not name.startswith('_'):
        yield name.ljust(maxlen) + ' = ' + str(value)
  formatted = []
  formatted.extend(preprocess(symbols))
  formatted.extend('')
  formatted.extend(preprocess(desc_symbols))
  if not symbols and not desc_symbols:
    formatted.append('pass')
  return '\n'.join(formatted)


def load_template(name):
  ''' Loads the contents of a template from the `templates` directory. '''

  dirname = os.path.dirname(__file__)
  filename = os.path.join(dirname, 'templates', name + '.template')
  with open(filename, 'r') as fp:
    return fp.read()


def render_template(__template_string, **context):
  ''' Renders the template string *__template_string* into a new string
  replacing variables annotated with ``{{varname}}`` from variables
  in the *context*. The indentation of the variables is kept. '''

  expr = r'^(.*)\{\{(\w+)\}\}'
  def replace(match):
    pre = match.group(1)
    name = match.group(2)
    value = context[name]
    lines = value.split('\n')

    if not lines:
      return pre

    result = []
    result.append(pre + lines[0])
    for line in lines[1:]:
      result.append(' ' * len(pre) + line)

    return '\n'.join(result)

  return re.sub(expr, replace, __template_string, flags=re.M)


# =====================================================================
#  Py-Compile Stuff
# =====================================================================

def shell_quote(s):
  if os.name == 'nt' and os.sep == '\\':
    s = s.replace('"', '\\"')
    if re.search('\s', s):
      s = '"' + s + '"'
    return s
  else:
    return pipes.quote(s)


def shell_run(command, **kwargs):
  if isinstance(command, (list, tuple)):
    command = ' '.join(shell_quote(x) for x in command)
  print(command)
  return subprocess.call(command, shell=True, **kwargs)


def get_pyfile_pair(filename):
  ''' Given the filename of a Python source or byte compiled filename,
  returns a pair of the source and byte compiled filename. '''

  if filename.endswith('.py'):
    filename = filename[:-3]
  elif filename.endswith('.pyc'):
    filename = filename[:-4]
  else:
    raise ValueError('filename does not end with .py or .pyc')

  return (filename + '.py', filename + '.pyc')


def bytecompile(pybin, source, outdir=None):
  ''' Compiles the specified *source* file or package directory to the
  output file (or package directry) to the specified output directory
  *outdir*. Regardless of PEP 3147, this will always place the byte
  compiled files in the old-style place. '''

  if pybin is not None:
    if outdir is None:
      outdir = os.path.dirname(source)
    command = [pybin, __file__, 'bytecompile', source, outdir]
    return shell_run(command)

  def recurse(filename, basedir):
    if os.path.isfile(filename) and filename.endswith('.py'):
      cfile = filename[:-3] + '.pyc'
      cfile = os.path.join(outdir, os.path.relpath(cfile, basedir))
      print("  [c]", os.path.relpath(filename))
      py_compile.compile(filename, cfile)
    elif os.path.isdir(filename):
      for item in os.listdir(filename):
        recurse(os.path.join(filename, item), basedir)

  print("Bytecompiling", os.path.relpath(source))
  recurse(source, os.path.dirname(source))


def bdist_egg(pybin, package, outdir, exclude_source=True, quiet=True):
  ''' Assuming *package* is the path to a directory that contains a
  `setup.py` script, this script will generate a Python binary egg
  distribution of the package to the specified *outdir*. '''

  if not os.path.isdir(outdir):
    os.makedirs(outdir)
  command = [pybin, 'setup.py']
  if quiet:
    command.append('-q')
  command += ['bdist_egg', '--dist-dir', outdir]
  if exclude_source:
    command.append('--exclude-source-files')
  print("\nCreating Binary distribution of", os.path.relpath(package),
    "at", os.path.relpath(outdir))
  return shell_run(command, cwd=package)


def create_egg(pybin, source, dest, exclude_source=True):
  ''' Creates a Python Egg (without EGG-INFO) from the specified *source*
  python module using the specified *pybin*. The egg will be saved to *dest*.
  Unlike `bdist_egg()`, this function really creates the zipfile at *dest*.

  If *source* is a list, its items are assumed to be filenames instead
  that are all supposed to be packed into the output egg. '''

  if not source:
    raise ValueError('no sources specified')
  if isinstance(source, str):
    source = [source]

  if pybin is not None:
    command = [pybin, __file__, 'create_egg'] + source + [dest, str(bool(exclude_source))]
    return shell_run(command)

  dirname = os.path.dirname(dest)
  if not os.path.exists(dirname):
    os.makedirs(dirname)

  print("\nCreating python egg at", os.path.relpath(dest))
  egg = zipfile.PyZipFile(dest, 'w')
  for filename in source:
    # Make sure that the file/s is/are being recompiled.
    if filename.endswith('.py'):
      bin_file = get_pyfile_pair(filename)[1]
      if os.path.isfile(bin_file):
        os.remove(bin_file)
    elif os.path.isdir(filename):
      purge(filename)

    print("  [+]", filename)
    egg.writepy(filename)
  return 0


def purge(directories, suffix='.pyc'):
  ''' Purge the specified *directories* and all its subfolders from
  byte-compile python cache folders. *directories* may also be a string
  of a single directory. '''

  if isinstance(directories, str):
    directories = [directories]

  def recurse(dirname):
    if os.path.isfile(dirname):
      if dirname.endswith('.py') or dirname.endswith('.pyc'):
        py, pyc = get_pyfile_pair(dirname)
        if os.path.isfile(pyc):
          os.remove(pyc)
    elif os.path.isdir(dirname):
      for item in os.listdir(dirname):
        item = os.path.join(dirname, item)
        if item.endswith(suffix) and os.path.isfile(item):
          os.remove(item)
        elif os.path.isdir(item):
          recurse(item)

  for dirname in directories:
    recurse(dirname)


class C4DDistro(object):
  ''' This class can be inherited to generate python archives from
  the information specified on class-level. The action happens when
  the class is being constructed. '''

  # source_dir
  # res_dir
  versions = ['2.6', '2.7']
  setuptools_packages = []
  manual_packages = []
  do_purge = True

  def __init__(self):
    self.results = []
    for version in self.versions:
      pybin = 'python' + version
      outdir = os.path.join(self.res_dir, 'modules' + version)
      for package in self.setuptools_packages:
        if not os.path.isabs(package):
          package = os.path.join(self.source_dir, package)
        bdist_egg(pybin, package, outdir)
        # XXX: Find output filename of egg.
      for package in self.manual_packages:
        name, files = package
        name = name.format(py='py' + version)
        outfile = os.path.join(outdir, name)
        files = [
          f if os.path.isabs(f) else os.path.join(self.source_dir, f)
          for f in files]
        create_egg(pybin, files, outfile)
        self.results.append(outfile)
        if self.do_purge:
          purge(files)


# =====================================================================
#  Python source protection
# =====================================================================

if __name__ == '__craftr__':
  load_module('maxon.c4d')

def protect_pyp(filename):
  ''' Runs the Cinema 4D source protect over the specified *filename*.
  Important: Requires the Apex plugin installed. '''

  app = maxon.c4d.app
  cwd = os.path.dirname(app)
  shell_run([app, '-apex-protect-source', filename, '-nogui'], cwd=cwd)

# =====================================================================
#  Main - invoked by some functions in this script in new processes
# =====================================================================

def main():
  if sys.argv[1] == 'bytecompile':
    bytecompile(None, sys.argv[2], sys.argv[3])
  elif sys.argv[1] == 'create_egg':
    sources = sys.argv[2:-2]
    dest = sys.argv[-2]
    exclude_source = True if sys.argv[-1] == 'True' else False
    create_egg(None, sources, dest, exclude_source)
  else:
    print("error: Unexpected command", sys.argv[1], file=sys.stderr)


if __name__ == "__main__":
  main()
