# craftr_module(maxon.c4d)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

load_module('rules')
load_module('platform')
is_windows = (platform.id == 'win')
is_mac = (platform.id == 'mac')
if not is_windows and not is_mac:
  raise EnvironmentError('only Windows and Mac OS are supported')

import os, re, craftr

# path
# release
# arch
setdefault('debug', False)

mode = 'debug' if debug else 'release'

# =====================================================================
#   Evaluate pre-conditions and detect Cinema 4D path and release
# =====================================================================

if defined('path'):
  path = normpath(path)
else:
  path = normpath(__file__ + '/../../..')

if not defined('release'):
  # Try to deduce the release number from the installation path.
  match = re.search('Cinema\s+4D\s+R(\d+)', path, re.I)
  if match:
    release = int(match.group(1))
  elif os.path.isfile(join(path, 'CINEMA 4D 64 Bit.exe')):
    # If that didn't work, pre-R16 versions had the Windows executable
    # named like this, and it was also distributed with the Mac version.
    release = 15
  else:
    # We'll assume that we're working with the R16+ API.
    release = 16
  del match

if is_windows:
  _compiler = load_module('compiler.msvc').CxxCompiler()
elif is_mac:
  _compiler = load_module('compiler.clang').CxxCompiler()
else:
  assert False

if not defined('arch'):
  _compiler.detect(silent=session.action != 'export')
  if _compiler.arch:
    arch = _compiler.arch
  else:
    arch = 'x64'

info('SDK Version: R{}, Target: {}, Compiler: {} v{}'.format(
  release, arch, _compiler.name, _compiler.version))

resource_dir = join(path, 'resource')
if release <= 15:
  source_dir = join(resource_dir, '_api')
else:
  source_dir = normpath(path + '/frameworks/cinema.framework/source')

# =====================================================================
#   Generate source and object file lists and include directories
# =====================================================================

sources = glob(source_dir + '/**/*.cpp')

includes = [
  source_dir,
  source_dir + '/c4d_customgui',
  source_dir + '/c4d_gv',
  source_dir + '/c4d_libs',
  source_dir + '/c4d_misc',
  source_dir + '/c4d_misc/datastructures',
  source_dir + '/c4d_misc/memory',
  source_dir + '/c4d_misc/utilities',
  source_dir + '/c4d_preview',
  source_dir + '/c4d_scaling',
  resource_dir + '/res/description']
if release <= 15:
  includes += glob(resource_dir + '/modules/*/res/description')
  includes += glob(path + '/modules/*/res/description')
  includes += glob(path + '/modules/*/*/res/description')
else:
  includes += glob(resource_dir + '/modules/*/description')
includes = list(map(normpath, includes))

# =====================================================================
#   Embedded Python support
# =====================================================================

if release >= 17:
  python_ver = '2.7'
elif release >= 12:
  python_ver = '2.6'

if defined('python_ver'):
  if release >= 16:
    python_res = join(resource_dir, 'modules', 'python')
  else:
    python_res = join(resource_dir, 'modules', 'python', 'res')

  if is_windows:
    python_arch = '86' if arch == 'x86' else '64'
    python_fw = join(python_res, 'Python.win' + python_arch + '.framework')
    python_lib = 'python' + python_ver.replace('.', '')
    python_lib_path = join(python_fw, 'libs')
    python_lib_full = join(python_lib_path, python_lib + '.lib')
    python_include = join(python_fw, 'include')
  elif is_mac:
    python_fw = join(python_res, 'Python.osx.framework')
    python_lib = 'Python.osx'
    python_lib_path = python_fw
    python_lib_full = join(python_lib_path, python_lib)
    python_include = join(python_fw, 'include', 'python' + python_ver)
  else:
    assert False

# =====================================================================
#   Determine application path
# =====================================================================

if is_windows:
  if arch == 'x64':
    if release < 16:
      app = join(path, 'CINEMA 4D 64 Bit.exe')
    else:
      app = join(path, 'CINEMA 4D.exe')
  elif arch == 'x86':
    app = join(path, 'CINEMA 4D.exe')
  else:
    assert False
elif is_mac:
  app = join(path, 'CINEMA 4D.app/Contents/MacOS/CINEMA 4D')
else:
  assert False

debug_args = ['-debug', '-g_alloc=debug', '-g_console=true']

# =====================================================================
#   Compiler settings
# =====================================================================

class MsvcCompiler(Translator):

  def __init__(self, arch, release, debug=False, **kwargs):
    super().__init__(arch=arch, release=release, debug=debug, **kwargs)
    self.compiler_info = load_module('compiler.msvc').CxxCompiler()
    self.compiler_info.detect()

  def _validate(self, arch, release, msvc_runtime_library=None, **kwargs):
    assert arch in ('x86', 'x64'), arch
    assert release in range(13, 18), release

    if msvc_runtime_library is None:
      msvc_runtime_library = 'static' if release <= 15 else 'dynamic'
      self.result.options['msvc_runtime_library'] = msvc_runtime_library
    assert msvc_runtime_library in ('static', 'dynamic'), msvc_runtime_library

  def _validate_compile_100defines(self, arch, release, debug, defines=(),
      legacy_api=False, **kwargs):
    self.result.options['defines'] = defines = list(defines)

    defines += ['__PC']
    if release >= 15:
      defines += ['MAXON_API', 'MAXON_TARGET_WINDOWS']
      defines += ['MAXON_TARGET_DEBUG'] if debug else ['MAXON_TARGET_RELEASE']
      if arch == 'x64':
        defines += ['MAXON_TARGET_64BIT']
    else:
      defines += ['_DEBUG', 'DEBUG'] if defines else ['NDEBUG']
      if arch == 'x64':
        defines += ['__C4D_64BIT', 'WIN64', '_WIN64']
      else:
        defines += ['WIN32', '_WIN32']

    if legacy_api:
      defines += ['__LEGACY_API']

  def _translate_compile_100base(self, arch, release, debug, msvc_runtime_library,
      includes=(), defines=(), additional_flags=(), exceptions=False, **kwargs):

    self.result.program = self.compiler_info.options['program']
    self.result.command += ('/nologo /c /W4 /WX- /MP /Gm- /Gs /Gy- '
      '/fp:precise /Zc:wchar_t- /Gd /TP /wd4062 /wd4100 /wd4127 /wd4131 '
      '/wd4201 /wd4210 /wd4242 /wd4244 /wd4245 /wd4305 /wd4310 /wd4324 '
      '/wd4355 /wd4365 /wd4389 /wd4505 /wd4512 /wd4611 /wd4706 /wd4718 '
      '/wd4740 /wd4748 /wd4996 /FC /errorReport:prompt /vmg /vms /w44263 '
      '/we4264').split()

    if self.compiler_info.version and self.compiler_info.version >= 'v18':
      self.result.command += ['/FS']  # required if multiple processes write to the PDB file (since v18)

    if msvc_runtime_library == 'dynamic':
      self.result.command += ['/MTd' if debug else '/MT']
    elif msvc_runtime_library == 'static':
      self.result.command += ['/MDd' if debug else '/MD']

    if debug:
      self.result.command += ['/Od', '/Zi', '/RTC1']
    else:
      self.result.command += ['/Ox', '/Oy-', '/Oi', '/Ob2', '/Ot', '/GF']

    if exceptions:
      self.result.command += ['/EHsc']

    self.result.command += ['/D{}'.format(x) for x in autoexpand(defines)]
    self.result.command += ['/I{}'.format(x) for x in autoexpand(includes)]
    self.result.command.extend(additional_flags)

  def _translate_compile_110autodeps(self, autodeps=True, **kwargs):
    if autodeps:
      self.result.command += ['/showIncludes']
      self.result.meta['deps'] = 'msvc'
      self.result.meta['msvc_deps_prefix'] = self.compiler_info.msvc_deps_prefix

  def _translate_compile_200inputs(self, **kwargs):
    self.result.command += ['%%in', '/Fo%%out']

  def _translate_lib(self, additional_flags=(), **kwargs):
    self.result.program = 'lib'
    self.result.command += ['/nologo', '/OUT:%%out', '%%in']
    self.result.command.extend(additional_flags)

  def _translate_dll(self, additional_flags=(), msvc_link_with=(), **kwargs):
    self.result.program = 'link'
    self.result.command += ['/nologo', '/DLL', '/OUT:%%out']
    if debug:
      self.result.command += ['/debug']
    self.result.command += ['%%in']
    self.result.command.extend(additional_flags)
    self.result.command.extend(msvc_link_with)

  def cdl(self, fn):
    return addsuffix(fn, '.cdl' if self['arch'] == 'x86' else '.cdl64')

  def obj(self, fn):
    return addsuffix(fn, '.obj')

  def bin(self, fn):
    return addsuffix(fn, '.exe')

  def dll(self, fn):
    return addsuffix(fn, '.dll')

  def lib(self, fn):
    return addsuffix(fn, '.lib')


class ClangCompiler(Translator):

  def __init__(self, arch, release, debug=False, **kwargs):
    super().__init__(arch=arch, release=release, debug=debug, **kwargs)
    self.compiler_info = load_module('compiler.clang').CxxCompiler()
    self.compiler_info.detect()

  def _validate(self, arch, release, stdlib=None, **kwargs):
    assert arch == 'x86_64', arch
    assert release in range(13, 18)

    if stdlib is None:
      stdlib = 'libstdc++' if release <= 15 else 'libc++'
      self.result.options['stdlib'] = stdlib
    assert stdlib in ('libstdc++', 'libc++')

  def _validate_compile_050defines(self, arch, release, debug, defines=(),
      legacy_api=False, **kwargs):
    self.result.options['defines'] = defines = list(defines)

    defines += ['C4D_COCOA', '__MAC']
    if release >= 15:
      defines += ['MAXON_API', 'MAXON_TARGET_OSX']
      defines += ['MAXON_TARGET_DEBUG'] if debug else ['MAXON_TARGET_RELEASE']
      if arch == 'x86_64':
        defines += ['MAXON_TARGET_64BIT']
    else:
      defines += ['_DEBUG', 'DEBUG'] if defines else ['NDEBUG']
      if arch == 'x86_64':
        defines += ['__C4D_64BIT',]

    if legacy_api:
      defines += ['__LEGACY_API']

  def _translate_compile_100base(self, arch, release, debug, stdlib,
      includes=(), defines=(), additional_flags=(), exceptions=False, **kwargs):

    self.result.program = self.compiler_info.options['program']
    if release <= 15:
      self.result.command += (
        '-fmessage-length=0 -fdiagnostics-show-note-include-stack '
        '-fmacro-backtrace-limit=0 -std=c++11 -Wno-trigraphs '
        '-fno-rtti -fpascal-strings '
        '-Wno-missing-field-initializers -Wno-missing-prototypes '
        '-Wno-non-virtual-dtor -Woverloaded-virtual -Wno-exit-time-destructors '
        '-Wmissing-braces -Wparentheses -Wno-switch -Wunused-function '
        '-Wunused-label -Wno-unused-parameter -Wunused-variable -Wunused-value '
        '-Wno-empty-body -Wno-uninitialized -Wunknown-pragmas -Wno-shadow '
        '-Wno-four-char-constants -Wno-conversion -Wno-constant-conversion '
        '-Wno-int-conversion -Wno-bool-conversion -Wno-enum-conversion '
        '-Wno-shorten-64-to-32 -Wno-newline-eof -Wno-c++11-extensions '
        '-fasm-blocks -fstrict-aliasing -Wdeprecated-declarations '
        '-Wno-invalid-offsetof -mmacosx-version-min=10.6 -msse3 '
        '-fvisibility=hidden -fvisibility-inlines-hidden -Wno-sign-conversion '
        '-Wno-logical-op-parentheses -fno-math-errno').split()
    else:
      self.result.command += (
        '-fmessage-length=0 -fdiagnostics-show-note-include-stack '
        '-fmacro-backtrace-limit=0 -std=c++11 -Wno-trigraphs '
        '-fno-rtti -fpascal-strings -Wmissing-field-initializers '
        '-Wmissing-prototypes -Wdocumentation -Wno-non-virtual-dtor '
        '-Woverloaded-virtual -Wno-exit-time-destructors -Wmissing-braces '
        '-Wparentheses -Wno-switch -Wunused-function -Wunused-label '
        '-Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body '
        '-Wuninitialized -Wunknown-pragmas -Wshadow -Wno-four-char-constants '
        '-Wno-conversion -Wconstant-conversion -Wint-conversion '
        '-Wbool-conversion -Wenum-conversion -Wsign-compare -Wshorten-64-to-32 '
        '-Wno-newline-eof -Wno-c++11-extensions -fasm-blocks -fstrict-aliasing '
        '-Wdeprecated-declarations -Winvalid-offsetof -mmacosx-version-min=10.7 '
        '-msse3 -fvisibility=hidden -fvisibility-inlines-hidden '
        '-Wno-sign-conversion -fno-math-errno').split()

    if not exceptions:
      self.result.command += ['-fno-exceptions']

    if release <= 15:
      if debug:
        self.result.command += ['-include', join(source_dir, 'ge_mac_debug_flags.h')]
      else:
        self.result.command += ['-include', join(source_dir, 'ge_mac_flags.h')]

    self.result.command += ['-stdlib={}'.format(stdlib)]
    self.result.command += ['-g', '-O0'] if debug else ['-O3']
    self.result.command += ['-D{}'.format(x) for x in autoexpand(defines)]
    self.result.command += ['-I{}'.format(x) for x in autoexpand(includes)]

  def _translate_compile_110autodeps(self, autodeps=True, depfile=None, **kwargs):
    if not depfile:
      depfile = '%%out.d'
    if autodeps:
      self.result.command += ['-MMD', '-MF', depfile]
      self.result.meta['deps'] = 'gcc'
      self.result.meta['depfile'] = depfile

  def _translate_compile_200inputs(self, **kwargs):
    self.result.command += ['-c', '%%in', '-o', '%%out']

  def _translate_lib(self, additional_flags=(), **kwargs):
    self.result.program = 'ar'
    self.result.command += ['rcs']
    self.result.command.extend(additional_flags)
    self.result.command += ['%%out', '%%in']

  def _translate_dll(self, stdlib, additional_flags=(), **kwargs):
    self.result.program = self.compiler_info.options['program']
    self.result.command += ['-shared', '-stdlib={}'.format(stdlib)]
    if debug:
      self.result.command += ['-g']
    self.result.command += ['%%in', '-o', '%%out']

  def cdl(self, fn):
    return addsuffix(fn, '.dylib')

  def obj(self, fn):
    return addsuffix(fn, '.o')

  def bin(self, fn):
    return fn

  def dll(self, fn):
    return addsuffix(fn, '.dylib')

  def lib(self, fn):
    return addsuffix(addprefix(fn, 'lib'), '.a')


if is_windows:
  cxx = MsvcCompiler(arch, release, debug, includes=includes)
elif is_mac:
  cxx = ClangCompiler(arch, release, debug, includes=includes)
else:
  assert False

def objects(sources, src_dir=None, obj_dir='obj', module=None, options=None, **kwargs):
  module = get_calling_module(module)
  options = options or {}
  sources = autoexpand(sources)
  src_dir = src_dir or commonpath(sources)
  obj_dir = join(module.identifier, obj_dir)
  objects = cxx.obj(rmvsuffix(move(sources, src_dir, obj_dir)))
  result = cxx.translate('_compile', **options)
  return module.target(
    inputs=sources,
    outputs=objects,
    foreach=True,
    description = 'Building Object %%out',
    command=result,
    meta_type='objects',
    meta_deps=result.meta.get('deps'),
    meta_depfile=result.meta.get('depfile'),
    **kwargs
  )


def static_library(filename, inputs, module=None, includes=(), options=None, **kwargs):
  module = get_calling_module(module)
  options = options or {}
  result = cxx.translate('_lib', **options)
  filename = normpath(filename, module.identifier)
  return module.target(
    inputs=inputs,
    outputs=cxx.lib(filename),
    description = 'Building Library %%out',
    command=result,
    meta_type='static_library',
    meta_includes=autoexpand(includes),
    **kwargs
  )


def plugin(filename, inputs, module=None, options=None, **kwargs):
  module = get_calling_module(module).locals
  options = options or {}
  options['includes'] = includes = list(options.get('includes', []))
  options['defines'] = includes = list(options.get('defines', []))
  inputs = list(inputs)
  if library not in inputs:
    inputs.append(library)
  for item in inputs:
    if isinstance(item, Target):
      includes.extend(item.meta.get('includes', []))
      includes.extend(item.meta.get('defines', []))
  result = cxx.translate('_dll', **options)

  # Add the plugin as order only dependency to the run target.
  run.order_only_deps.append(cxx.cdl(filename))

  return module.target(
    inputs=inputs,
    outputs=cxx.cdl(filename),
    description = 'Building Plugin %%out',
    command=result,
    meta_type='shared_library',
    meta_deps=result.meta.get('deps'),
    meta_depfile=result.meta.get('depfile'),
    **kwargs
  )


object_files = objects(
  sources = sources,
)

library = static_library(
  filename = 'c4dsdk',
  inputs = object_files,
  includes = includes,
  default = True,
)

run = rules.run(
  executable = [app],
  additional_flags = debug_args,
  no_dependency = True,
)

if is_mac:
  lldb = rules.run(
    executable = ['lldb'],
    additional_flags = ['--'] + run.commands[0],
    no_dependency = True,
  )
