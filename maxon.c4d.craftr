# craftr_module(maxon.c4d)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os, re, craftr

load_module('platform')

# path
# release
# arch
setdefault('debug', False)
setdefault('build_dir', join(project_dir, 'build'))

mode = 'debug' if debug else 'release'

# =====================================================================
#   Evaluate pre-conditions and detect Cinema 4D path and release
# =====================================================================

if defined('path'):
  path = normpath(path)
else:
  path = normpath(__file__ + '/../../..')

if not defined('release'):
  # Try to deduce the release number from the installation path.
  match = re.search('Cinema\s+4D\s+R(\d+)', path, re.I)
  if match:
    release = int(match.group(1))
  elif os.path.isfile(join(path, 'CINEMA 4D 64 Bit.exe')):
    # If that didn't work, pre-R16 versions had the Windows executable
    # named like this, and it was also distributed with the Mac version.
    release = 15
  else:
    # We'll assume that we're working with the R16+ API.
    release = 16
  del match

if platform.id == 'win':
  Cxx = load_module('compiler.msvc').CxxCompiler()
elif platform.id == 'mac':
  Cxx = load_module('compiler.clang').CxxCompiler()
else:
  error("unsupported OS '{}'".format(platform.name))

if not defined('arch'):
  Cxx.detect()
  arch = Cxx.arch

info('SDK Version: R{}, Target: {}, Compiler: {} v{}'.format(release, arch, Cxx.name, Cxx.version))

resource_dir = join(path, 'resource')
if release <= 15:
  source_dir = join(resource_dir, '_api')
else:
  source_dir = normpath(path + '/frameworks/cinema.framework/source')

# =====================================================================
#   Generate source and object file lists and include directories
# =====================================================================

obj = platform.obj
lib = platform.lib
bin = platform.bin
dll = platform.dll

def gen_build_dir_base(debug):
  mode = 'debug' if debug else 'release'
  return 'r{}-{}-{}-{}'.format(release, platform.id, arch, mode)

build_dir = join(build_dir, gen_build_dir_base(debug), 'maxon.c4d')
sources = glob(source_dir + '/**/*.cpp')

includes = [
  source_dir,
  source_dir + '/c4d_customgui',
  source_dir + '/c4d_gv',
  source_dir + '/c4d_libs',
  source_dir + '/c4d_misc',
  source_dir + '/c4d_misc/datastructures',
  source_dir + '/c4d_misc/memory',
  source_dir + '/c4d_misc/utilities',
  source_dir + '/c4d_preview',
  source_dir + '/c4d_scaling',
  resource_dir + '/res/description']
if release <= 15:
  includes += glob(resource_dir + '/modules/*/res/description')
  includes += glob(path + '/modules/*/res/description')
  includes += glob(path + '/modules/*/*/res/description')
else:
  includes += glob(resource_dir + '/modules/*/description')
includes = list(map(normpath, includes))

# =====================================================================
#   Embedded Python support
# =====================================================================

if release >= 17:
  python_ver = '2.7'
elif release >= 12:
  python_ver = '2.6'

if defined('python_ver'):
  if release >= 16:
    python_res = join(resource_dir, 'modules', 'python')
  else:
    python_res = join(resource_dir, 'modules', 'python', 'res')

  if platform.id == 'win':
    python_arch = '86' if arch == 'x86' else '64'
    python_fw = join(python_res, 'Python.win' + python_arch + '.framework')
    python_lib = 'python' + python_ver.replace('.', '')
    python_lib_path = join(python_fw, 'libs')
    python_lib_full = join(python_lib_path, python_lib + '.lib')
    python_include = join(python_fw, 'include')
  elif platform.id == 'mac':
    python_fw = join(python_res, 'Python.osx.framework')
    python_lib = 'Python.osx'
    python_lib_path = python_fw
    python_lib_full = join(python_lib_path, python_lib)
    python_include = join(python_fw, 'include', 'python' + python_ver)
  else:
    assert False

# =====================================================================
#   Compiler settings
# =====================================================================

if platform.id == 'win':
  if arch not in ('x86', 'x64'):
    error("unexpected compiler architecture '{}'".format(arch))

  _default_runtime_lib = 'static' if release <= 15 else 'dynamic'

  if arch == 'x86':
    cdl = lambda x: addsuffix(x, '.cdl')
  else:
    cdl = lambda x: addsuffix(x, '.cdl64')

  cinc = lambda l: [['/I', x] for x in l]
  cdef = lambda l: [['/D', x] for x in l]
  obj_out = lambda x: '/Fo' + x
  bin_out = lambda x: '/Fe' + x

  defines = CommandBuilder()
  defines.append(['__PC', 'WINDOWS', '_CRT_SECURE_NO_WARNINGS', 'PSAPI_VERSION=1'])
  if arch == 'x86':
    defines.append(['WIN32', '_WIN32'])
  else:
    defines.append(['WIN64', '_WIN64'])
    if release >= 16:
      defines.append('MAXON_TARGET_64BIT')
    else:
      defines.append('__C4D_64BIT')
  if release <= 15:
    defines.switch('debug',
      enabled=['DEBUG', '_DEBUG'],
      disabled=['NDEBUG'])
  else:
    defines.append(['MAXON_TARGET_WINDOWS', 'MAXON_API'])
    defines.switch('debug',
      enabled=['MAXON_TARGET_DEBUG'])
  defines.switch('legacy_api', enabled='__LEGACY_API')

  cxx = CommandBuilder()
  cxx.append('cl /nologo /c /W4 /WX- /MP /Gm- /Gs /Gy- /fp:precise /Zc:wchar_t- '
    '/Gd /TP /wd4062 /wd4100 /wd4127 /wd4131 /wd4201 /wd4210 /wd4242 /wd4244 '
    '/wd4245 /wd4305 /wd4310 /wd4324 /wd4355 /wd4365 /wd4389 /wd4505 /wd4512 '
    '/wd4611 /wd4706 /wd4718 /wd4740 /wd4748 /wd4996 /FC /errorReport:prompt '
    '/vmg /vms /w44263 /we4264'.split())
  if compiler.msvc.version >= 'v18':
    cxx.append('/FS')  # required if multiple processes write to the PDB file (since v18)
  cxx.switch('exceptions', enabled=['/EHsc'])
  cxx.switch('debug',
    enabled=['/Od', '/Zi', '/RTC1'],
    disabled=['/Ox', '/Oy-', '/Oi', '/Ob2', '/Ot', '/GF'])
  @cxx.append
  def _cxx_msvc_runtime_library(options):
    debug = options.get('debug', False)
    lib = options.get('msvc_runtime_library', _default_runtime_lib)
    if lib == 'static':
      return ['/MTd' if debug else '/MD']
    elif lib == 'dynamic':
      return ['/MDd' if debug else '/MD']
    else:
      raise ValueError('invalid msvc_runtime_library: {!r}'.format(lib))
  cxx.append(['%%in', '/Fo%%out'])

  ar = CommandBuilder(['lib', '/nologo', '/OUT:%%out', '%%in'])

  link = CommandBuilder(['link', '/nologo', '/DLL', '/OUT:%%out'])
  link.switch('debug', enabled='/debug')
  link.append('%%in')

elif platform.id == 'mac':
  if arch != 'x86_64':
    error("unexpected compiler architecture '{}'".format(arch))
  cdl = lambda x: addsuffix(x, '.dylib')

  cinc = lambda l: [['-I', x] for x in l]
  cdef = lambda l: [['-D', x] for x in l]
  obj_out = lambda x: ['-o', x]
  bin_out = lambda x: ['-o', x]

  _default_stdlib = 'libstdc++' if release <= 15 else 'libc++'

  defines = CommandBuilder()
  defines.switch('legacy_api', enabled='__LEGACY_API')
  if release <= 15:
    # All other defines will be set by ge_mac<_debug>_flags.h
    defines.append('C4D_COCOA')
  else:
    # todo: Is it also the same for R17 or does this apply to R16 only?
    defines.append(['__MAC', '__64BIT', 'MAXON_TARGET_OSX',
      'MAXON_TARGET_64BIT', 'MAXON_API'])
    defines.switch('debug',
      enabled='MAXON_TARGET_DEBUG',
      disabled='MAXON_TARGET_RELEASE')

  cxx = CommandBuilder()
  if release <= 15:
    cxx.append('clang++ -c -arch x86_64 '
      '-fmessage-length=0 -fdiagnostics-show-note-include-stack '
      '-fmacro-backtrace-limit=0 -std=c++11 -Wno-trigraphs '
      '-fno-rtti -fpascal-strings '
      '-Wno-missing-field-initializers -Wno-missing-prototypes '
      '-Wno-non-virtual-dtor -Woverloaded-virtual -Wno-exit-time-destructors '
      '-Wmissing-braces -Wparentheses -Wno-switch -Wunused-function '
      '-Wunused-label -Wno-unused-parameter -Wunused-variable -Wunused-value '
      '-Wno-empty-body -Wno-uninitialized -Wunknown-pragmas -Wno-shadow '
      '-Wno-four-char-constants -Wno-conversion -Wno-constant-conversion '
      '-Wno-int-conversion -Wno-bool-conversion -Wno-enum-conversion '
      '-Wno-shorten-64-to-32 -Wno-newline-eof -Wno-c++11-extensions '
      '-fasm-blocks -fstrict-aliasing -Wdeprecated-declarations '
      '-Wno-invalid-offsetof -mmacosx-version-min=10.6 -msse3 '
      '-fvisibility=hidden -fvisibility-inlines-hidden -Wno-sign-conversion '
      '-Wno-logical-op-parentheses -fno-math-errno'.split())
  else:
    cxx.append('clang++ -c -arch x86_64 -fmessage-length=0 '
      '-fdiagnostics-show-note-include-stack '
      '-fmacro-backtrace-limit=0 -std=c++11 -Wno-trigraphs '
      '-fno-rtti -fpascal-strings -Wmissing-field-initializers '
      '-Wmissing-prototypes -Wdocumentation -Wno-non-virtual-dtor '
      '-Woverloaded-virtual -Wno-exit-time-destructors -Wmissing-braces '
      '-Wparentheses -Wno-switch -Wunused-function -Wunused-label '
      '-Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body '
      '-Wuninitialized -Wunknown-pragmas -Wshadow -Wno-four-char-constants '
      '-Wno-conversion -Wconstant-conversion -Wint-conversion '
      '-Wbool-conversion -Wenum-conversion -Wsign-compare -Wshorten-64-to-32 '
      '-Wno-newline-eof -Wno-c++11-extensions -fasm-blocks -fstrict-aliasing '
      '-Wdeprecated-declarations -Winvalid-offsetof -mmacosx-version-min=10.7 '
      '-msse3 -fvisibility=hidden -fvisibility-inlines-hidden '
      '-Wno-sign-conversion -fno-math-errno'.split())
  cxx.switch('exceptions', disabled=['-fno-exceptions'])
  cxx.switch('debug', disabled=['-O3'], enabled=['-g', '-O0'])
  if release <= 15:
    cxx.switch('debug',
      enabled=['-include', join(source_dir, 'ge_mac_debug_flags.h')],
      disabled= ['-include', join(source_dir, 'ge_mac_flags.h')])
  cxx.append(['%%in', '-o', '%%out'])
  @cxx.append
  def _cxx_stdlib(options):
    stdlib = options.get('stdlib', _default_stdlib)
    if stdlib not in ('libc++', 'libstdc++'):
      raise ValueError('invalid stdlib: {!r}'.format(stdlib))
    return ['-stdlib=' + stdlib]

  ar = CommandBuilder(['ar', 'rcs', '%%out', '%%in'])

  link = CommandBuilder(['clang++', '-shared'])
  link.append(_cxx_stdlib)
  link.switch('debug', enabled='-g')
  link.append(['%%in', '-o', '%%out'])

else:
  assert False

# =====================================================================
#   Determine application path
# =====================================================================

if platform.id == 'win':
  if arch == 'x64':
    if release < 16:
      app = join(path, 'CINEMA 4D 64 Bit.exe')
    else:
      app = join(path, 'CINEMA 4D.exe')
  elif arch == 'x86':
    app = join(path, 'CINEMA 4D.exe')
  else:
    assert False
elif platform.id == 'mac':
  app = join(path, 'CINEMA 4D.app/Contents/MacOS/CINEMA 4D')
else:
  assert False

debug_args = ['-debug', '-g_alloc=debug', '-g_console=true']

# =====================================================================
#   Rules
# =====================================================================

def cxx_objects(sources, includes=(), defines=(), additional_flags=(),
    objects=None, objects_dir=None, base_dir=None, module=None, **options):
  ''' Comple the C++ *sources* into object files.

  Options:
    debug (bool): Automatically read from the calling module if omitted.
    legacy_api (bool): True if the `__LEGACY_API` macro should be defined.
    msvc_runtime_library (str): The runtime library to use on Windows.
      Valid values are `"dynamic"` and `"static"`. The default depends
      on the Cinema 4D release.
    stdlib (str): The name of the standard library to link with on Mac OS.
  '''

  if not sources:
    raise ValueError('no sources specified')

  valid_options = 'debug legacy_api msvc_runtime_library stdlib'
  craftr.utils.accept_keys(options, valid_options, 'option')
  module = craftr.utils.get_calling_module(module)
  options.setdefault('debug', module.get('debug', False))

  if not all(x.endswith('.cpp') for x in sources):
    raise ValueError('can only compile .cpp files')

  if objects is None:
    if objects_dir is None:
      build_dir = module.get('build_dir', None)
      if build_dir is None:
        raise ValueError('build_dir not defined')
      objects_dir = join(build_dir, 'obj')
    if base_dir is None:
      base_dir = craftr.utils.path.commonpath(sources)
    objects = move(obj(rmvsuffix(sources)), base_dir, objects_dir)

  if len(objects) != len(sources):
    raise ValueError('len(objects) != len(sources)')

  includes = autoexpand([self.includes, includes])
  defines = autoexpand([self.defines(**options), defines])
  flags = cxx(**options)
  flags.extend(cinc(includes))
  flags.extend(cdef(defines))
  flags.extend(additional_flags)

  return module.target(inputs=sources, outputs=objects,
    command=flags, foreach=True, meta_type='objects', meta_includes=includes,
    meta_defines=defines, meta_additional_flags=additional_flags,
    description='Building Object %%out')


def cxx_plugin(filename, inputs=None, libs=(), external_libs=(),
    additional_flags=(), module=None, **options):
  ''' Generate a Cinema 4D plugin from the specified *inputs*. The
  *inputs* may be a list of object files or targets. If a target is
  specified, the meta value `"type"` is used to determine wether it
  lists object files or a library file to link with.

  Arguments:
    filename (str): The name of the plugin file. If a relative path is
      given, it will be placed in the calling module's project dir.
    inputs (list of {Target, list of str}): List of inputs. An input
      can be a Target or a list of object filenames. A target can be
      an object target or a library target.
    libs (list of str): A list of library filenames that are required
      to link the plugin dynamic library. The libraries listed here
      are considered to be buildable by the build system.
    external_libs (list of str): A list of library filenames that are
      to be linked with the plugin dynamic library. These are not
      considered to be buildable by the build system.
    additional_flags (list of str): A list of additional flags for
      the linker.
    module (Module): The module to declare the target in. Defaults
      to the calling module.
    **options: See the #Options section.
  Options:
    debug (bool): Automatically read from the calling module if omitted.
    stdlib (str): The name of the standard library to link with on Mac OS.
  '''

  if not filename:
    raise ValueError('no filename specified')
  if not inputs:
    raise ValueError('no inputs specified')

  valid_options = 'debug stdlib'
  craftr.utils.accept_keys(options, valid_options, 'option')
  module = craftr.utils.get_calling_module(module)
  options.setdefault('debug', module.get('debug', False))

  objects = []
  libs = autoexpand(libs)
  for input_ in inputs:
    if isinstance(input_, craftr.runtime.Target):
      ttype = input_.meta.get('type')
      if ttype == 'objects':
        objects.append(input_.outputs)
      elif ttype == 'library':
        if len(input_.outputs) != 1:
          message = "expected 1 output filename for library target ({!r})"
          raise ValueError(message.format(input_.identifier))
        libs.append(input_.outputs[0])
      else:
        message = "not sure what to do with target {!r}"
        raise ValueError(message.format(input_.identifier))
    else:
      objects.extend(autoexpand(_input))

  if not os.path.isabs(filename):
    filename = os.path.join(module.get('project_dir'), filename)
  filename = self.cdl(filename)

  libs = list(libs)
  libs.append(Library.outputs[0])

  flags = link(**options)
  flags.extend(libs)
  flags.extend(external_libs)
  flags.extend(additional_flags)
  return module.target(inputs=objects, outputs=[filename],
    requires=libs, command=flags, meta_type='c4d_plugin',
    description='Linking C4D Plugin %%out')


def cxx_library(inputs, filename, includes=(), library_dir=None,
    additional_flags=(), module=None):
  ''' Create a static library with the specified *name* in the
  *library_dir* from the *inputs*. All inputs must be object files or
  targets that generate object files.

  Arguments:
    target_name (str): The name of the target. Automatically deduced
      using Target Name Deduction if omitted.
    filename (str): The name of the library. An absolute path can be
      specified here. The filename must not have a suffix, it is added
      automatically.
    inputs (list of {Target, list of str}): List of object targets or
      object file names to create the library from.
    includes (list of str): A list of include directories that must
      be used to use the library.
    library_dir (str): The output directory of the library. If not
      specified, it will be derived from the calling modules build
      directory.
    additional_flags (list of str): Additional flags for the archiver.
    module (Module): A module to declare the target for. Defaults to
      the calling module.
  '''

  if not inputs:
    raise ValueError('no inputs specified')

  module = craftr.utils.get_calling_module(module)
  objects = []
  for input_ in inputs:
    if isinstance(input_, craftr.runtime.Target):
      ttype = input_.meta.get('type')
      if ttype == 'objects':
        objects.extend(input_.outputs)
      else:
        message = "not sure what to do with target {!r}"
        raise ValueError(message.format(input_.identifier))
    else:
      objects.extend(autoexpand(input_))

  if not filename:
    raise ValueError('filename must not be empty')

  if not os.path.isabs(filename):
    if not library_dir:
      build_dir = module.get('build_dir', None)
      if build_dir is None:
        raise ValueError('build_dir not defined')
      library_dir = build_dir
    filename = os.path.join(library_dir, filename)
  filename = lib(filename)

  includes = autoexpand(includes)
  return module.target(inputs=objects, outputs=[filename],
    command=ar(), meta_type='library', meta_includes=includes,
    description='Creating Library %%out')


# =====================================================================
#   SDK Targets
# =====================================================================

Objects = cxx_objects(
  sources = sources,
)

Library = cxx_library(
  filename = 'c4dsdk',
  inputs = [Objects],
)
